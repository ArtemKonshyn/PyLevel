---


---

<h1 id="celery">Celery</h1>
<p><img src="https://i.imgur.com/eUUBQaQ.jpg" alt="enter image description here"></p>
<h2 id="план">План</h2>
<ol>
<li>Что надо знать до Celery</li>
<li>Celery - распределённая очередь задач
<ol>
<li>Как работает Celery</li>
<li>Брокеры</li>
<li>Установка Celery и брокера Redis</li>
</ol>
</li>
<li>Celery и Python</li>
<li>Celery и Django</li>
<li>Литература</li>
</ol>
<h3 id="что-надо-знать-до-celery">Что надо знать до Celery</h3>
<p><strong>Процесс</strong> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.</p>
<p><strong>Поток</strong> использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.<br>
Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.</p>
<p><strong>Синхронным</strong> (synchronous) называется такое взаимодействие между компонентами, при котором клиент, отослав запрос, блокируется и может продолжать работу только после получения ответа от сервера. По этой причине такой вид взаимодействия называют иногда блокирующим (blocking).</p>
<p>В рамках <strong>асинхронного</strong> (asynchronous) или неблокирующего (non blocking) взаимодействия клиент после отправки запроса серверу может продолжать работу, даже если ответ на запрос еще не пришел. Асинхронное взаимодействие позволяет получить более высокую производительность системы за счет использования времени между отправкой запроса и получением ответа на него для выполнения других задач. Другое важное преимущество асинхронного взаимодействия — меньшая зависимость клиента от сервера, возможность продолжать работу, даже если машина, на которой находится сервер, стала недоступной. Это свойство используется для организации надежной связи между компонентами, даже если и клиент, и сервер не все время находятся в рабочем состоянии.<br>
<img src="https://media.proglib.io/wp-uploads/2018/07/introducing-the-volley-http-library-smashing-magazine.png" alt="асинхронный запрос к серверу"></p>
<p><strong>NoSQL</strong> (от англ. not only SQL — не только SQL) — термин, обозначающий ряд подходов, направленных на реализацию систем управления базами данных, имеющих существенные отличия от моделей, используемых в традиционных реляционных СУБД с доступом к данным средствами языка SQL. Применяется к базам данных, в которых делается попытка решить проблемы масштабируемости и доступности за счёт атомарности (англ. atomicity) и согласованности данных (англ. consistency). <a href="https://www.bigdataschool.ru/wiki/nosql#:~:text=NoSQL%20%E2%80%93%20%D1%8D%D1%82%D0%BE%20%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4%20%D0%BA%20%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8,%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%89%D0%B8%D0%B9%D1%81%D1%8F%20%D0%BE%D1%82%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%20%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D1%85%20%D0%A1%D0%A3%D0%91%D0%94.">Подробнее тут</a></p>
<p><img src="https://www.bigdataschool.ru/wp-content/uploads/2019/12/%D0%BD%D1%81%D0%BA%D0%BB_2.png" alt="NoSQL-базы данных"></p>
<h2 id="celery---распределённая-очередь-задач">Celery - распределённая очередь задач</h2>
<p><img src="https://docs.celeryproject.org/en/stable/_static/celery_512.png" alt="Logo"><br>
Celery это ничто иное как распределённая очередь задач, реализованная на языке Python.</p>
<p>Celery - это простая, гибкая и надежная распределенная система для обработки огромного количества сообщений, включаюзя в себя инструменты, необходимые для поддержки такой системы.</p>
<p>Это очередь задач с упором на обработку в реальном времени, а также с поддержкой планирования задач.</p>
<p>Celery имеет открытый исходный код и находится под лицензией BSD.</p>
<p>Итак, что же умеет <a href="https://docs.celeryproject.org/en/stable/">Celery</a>:</p>
<ul>
<li>Выполнять асинхронно задания</li>
<li>Выполнять периодические задания(умная замена cron)</li>
<li>Выполнять отложенные задания</li>
<li>Распределенное выполнение (может быть запущен на N серверах)</li>
<li>В пределах одного worker’а возможно конкурентное выполнение нескольких задач(одновременно)</li>
<li>Выполнять задание повторно, если вылез exception</li>
<li>Ограничивать количество заданий в единицу времени (rate limit, для задания или глобально)</li>
<li>Несложно мониторить выполнение заданий</li>
<li>Выполнять подзадания</li>
<li>Присылать отчеты об exception’ах</li>
<li>Проверять выполнилось ли задание</li>
</ul>
<h3 id="как-работает-celery">Как работает Celery</h3>
<p><img src="https://webmonstr.com/media/course/python-course/36-django-celery/images/2.png" alt="start page"></p>
<h4 id="brocker--брокер">Brocker  (Брокер)</h4>
<p>Брокер сообщений (он же диспетчер очереди) — это посредник(транспорт), который принимает и отдает сообщения (задачи) между отдельными модулями/приложениями внутри некоторой сложной системы, где модули/приложения должны общаться между собой — то есть пересылать данные друг другу.</p>
<h4 id="worker-воркер">Worker (Воркер)</h4>
<p>Воркер это отдельно запущенный процесс для выполнения определённых задач, Celery запускается на одном или нескольких воркерах, что бы выполнять задачи паралельно на каждом воркере.</p>
<h4 id="back-end-бэкэнд">Back-end (Бэкэнд)</h4>
<p>Бэкэнд в случае с Celery выступает в качестве хранилища результатов выполнения задач.</p>
<p><img src="https://www.ovh.com/blog/wp-content/uploads/2020/02/51EA37AB-E3E5-453F-9EFD-92414C84523F-1024x572.jpeg" alt=""></p>
<ul>
<li>
<p><strong>Producer</strong>  (поставщик) ‒ программа, отправляющая сообщения.</p>
</li>
<li>
<p><strong>Queue</strong>  (очередь) ‒ очередь сообщений(задач). Она существует внутри брокера. Любое количество поставщиков может отправлять сообщения в одну очередь, также любое количество подписчиков может получать сообщения из одной очереди. В схемах очередь будет обозначена стеком и подписана именем:</p>
</li>
<li>
<p><strong>Consumer</strong>  (подписчик) ‒ программа, принимающая сообщения. Обычно подписчик находится в состоянии ожидания сообщений.</p>
</li>
</ul>
<p>Поставщик, подписчик и брокер не обязаны находиться на одной физической машине.</p>
<h3 id="брокеры">Брокеры</h3>
<p><strong><a href="https://ru.wikipedia.org/wiki/AMQP">AMQP</a></strong><br>
(Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Основная идея состоит в том, что отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет маршрутизацию, возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений.</p>
<p><strong><a href="https://www.rabbitmq.com/download.html">RabbitMQ</a></strong><br>
RabbitMQ – это брокер сообщений с открытым исходным кодом. Он маршрутизирует собщения по всем базовым принципам протокола AMQP описанным в спецификации. Отправитель передает сообщение брокеру а тот доставляет его получателю. RabbitMQ реализует и дополняет протокол AM</p>
<p><strong><a href="https://redis.io/">Redis</a></strong><br>
Redis (расшифровывается как <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver) – это быстрое хранилище данных типа «ключ‑значение» в памяти с открытым исходным кодом для использования в качестве базы данных, кэша, брокера сообщений или очереди.</p>
<p>Redis это  <code>NoSQL</code>  база данных! Для Celery крайне рекомендую использовать именно его.</p>
<p><img src="https://www.botreetechnologies.com/blog/wp-content/uploads/2020/12/celery-architecture.jpg" alt="Implementing Celery using Django for Background Task Processing - BoTree  Technologies"></p>
<h3 id="установка-celery-и-брокера-redis">Установка Celery и брокера Redis</h3>
<pre class=" language-python"><code class="prism  language-python">pip install celery
</code></pre>
<p><code>Celery 4.0+</code> официально уже не поддерживается для Windows<br>
Варианты запуска<br>
0. Использовать Linux</p>
<ol>
<li><a href="https://habr.com/ru/post/490040/">Docker</a></li>
<li><a href="https://www.codedisciples.in/celery-windows.html">WSL 2</a> (для Windows 10)</li>
<li><a href="https://www.distributedpython.com/2018/08/21/celery-4-windows/">Переменная окружения</a> или <a href="https://github.com/celery/celery/issues/4081#issuecomment-408581158">прямо в коде</a></li>
</ol>
<p><strong>Redis</strong><br>
Установка самого сервиса</p>
<p><code>sudo apt install redis-server</code></p>
<pre class=" language-bash"><code class="prism  language-bash">artem@HP:~$ redis-server
17624:C 01 Mar 2021 02:50:02.381 <span class="token comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span>
17624:C 01 Mar 2021 02:50:02.381 <span class="token comment"># Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=17624, just started</span>
17624:C 01 Mar 2021 02:50:02.381 <span class="token comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span>
17624:M 01 Mar 2021 02:50:02.382 * Increased maximum number of <span class="token function">open</span> files to 10032 <span class="token punctuation">(</span>it was originally <span class="token keyword">set</span> to 1024<span class="token punctuation">)</span>.
17624:M 01 Mar 2021 02:50:02.383 <span class="token comment"># Could not create server TCP listening socket *:6379: bind: Address already in use</span>

artem@HP:~$ redis-cli
127.0.0.1:6379<span class="token operator">&gt;</span> <span class="token function">ping</span>
PONG
127.0.0.1:6379<span class="token operator">&gt;</span> <span class="token keyword">set</span> foo bar
OK
127.0.0.1:6379<span class="token operator">&gt;</span> get foo
<span class="token string">"bar"</span>
127.0.0.1:6379<span class="token operator">&gt;</span> 
</code></pre>
<p>Для работы необходимо так же необходима и библиотека</p>
<pre class=" language-python"><code class="prism  language-python">pip install redis
</code></pre>
<h3 id="celery-и-python">Celery и Python</h3>
<p>Создаем файл <a href="http://tasks.py">tasks.py</a> и  “приложение”, в котором необходимо указать название (понадобится для указания брокеру) и брокера.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> celery <span class="token keyword">import</span> Celery  
  
broker_url <span class="token operator">=</span> <span class="token string">'redis://localhost'</span>  
app <span class="token operator">=</span> Celery<span class="token punctuation">(</span><span class="token string">'tasks'</span><span class="token punctuation">,</span> broker<span class="token operator">=</span>broker_url<span class="token punctuation">)</span>  
  
  
@app<span class="token punctuation">.</span>task  
<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>  
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
</code></pre>
<p>Мы описали задачу, и обозначили её через декоратор приложения селери.</p>
<p>Для того, что бы мы могли вызвать задачу, необходимо запустить селери как отдельное приложение:</p>
<pre><code>celery -A tasks worker --loglevel=INFO
</code></pre>
<p>консольная команда будет доступна после установки celery</p>
<p><code>-A app_name</code>  - указать имя приложения,<br>
<code>worker</code>  - запустить один воркер,<br>
<code>loglevel</code> - уровень подробностей</p>
<h3 id="запуск-и-обработка-результата">Запуск и обработка результата</h3>
<p>Для запуска задач, есть много разных способов, рассмотрим базовый.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> tasks <span class="token keyword">import</span> add
add<span class="token punctuation">.</span>delay<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code></pre>
<p>Для запуска задачи немедленно используется метод <code>delay</code> (сокращенный метод apply_async()).</p>
<p>Запуск задач возвращает не результат, а <code>AsyncResult</code>, для того что бы получать значения необходимо при создании приложения указать парамет <code>backend</code> который отвечает за место хранения результатов, таким параметром может быть Redis:</p>
<pre class=" language-python"><code class="prism  language-python">broker_url <span class="token operator">=</span> <span class="token string">'redis://localhost'</span>
app <span class="token operator">=</span> Celery<span class="token punctuation">(</span><span class="token string">'tasks'</span><span class="token punctuation">,</span> broker<span class="token operator">=</span>broker_url<span class="token punctuation">,</span> backend<span class="token operator">=</span>broker_url<span class="token punctuation">)</span>
</code></pre>
<p>Результат будет иметь достаточно большое кол-во методов и атрибутов.</p>
<p>Основные два метода это <code>ready</code> и <code>get</code></p>
<p><code>ready</code> - отвечает за то завершилась задача или еще в процессе.</p>
<p><code>get</code> - ждет выполнения задачи и возвращает результат. Рекомендуется использовать после <code>ready</code>, что бы не ждать выполнения впустую.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> add<span class="token punctuation">.</span>delay<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> result<span class="token punctuation">.</span>ready<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> result<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">8</span>
</code></pre>
<p>Иногда описание парметров задачи и ей вызов могут быть в совершенно разных местах, для этого существует механизм подписи:</p>
<pre class=" language-python"><code class="prism  language-python">s1 <span class="token operator">=</span> add<span class="token punctuation">.</span>s<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
res <span class="token operator">=</span> s1<span class="token punctuation">.</span>delay<span class="token punctuation">(</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>в этом примере <code>s1</code> это подпись задачи, тоесть задача заготовленная для выполнения, её можно сериализовать и отправить по сети, например, а выполнить в уже совершенно других местах.</p>
<p>Задачи можно группировать:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> celery <span class="token keyword">import</span> group
<span class="token keyword">from</span> proj<span class="token punctuation">.</span>tasks <span class="token keyword">import</span> add

group<span class="token punctuation">(</span>add<span class="token punctuation">.</span>s<span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="виды-запуска">Виды запуска</h3>
<p>Есть три варианта запуска тасков:</p>
<pre><code>apply_async(args[, kwargs[, …]])
</code></pre>
<p>Отправка сообщения с указанием дополнительных параметров</p>
<pre><code>delay(*args, **kwargs)
</code></pre>
<p>Отправка сообщения без каких либо параметров самого сообщения</p>
<pre><code>calling (__call__)
</code></pre>
<p>Просто вызов, декоратор не мешает нам просто вызвать функцию без селери :)</p>
<h3 id="основные-параметры-apply_async">Основные параметры apply_async()</h3>
<ol>
<li>сountdown - отправить через</li>
</ol>
<pre class=" language-python"><code class="prism  language-python">add<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> countdown<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># отправить через 10 секунд</span>
</code></pre>
<ol start="2">
<li>eta - отправить в конкретное время</li>
</ol>
<pre class=" language-python"><code class="prism  language-python">add<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eta<span class="token operator">=</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># отправить через 10 секунд</span>
</code></pre>
<ol start="3">
<li>expires - время после которого перестать выполнять задачу, можно указать как цифру так и время</li>
</ol>
<pre class=" language-python"><code class="prism  language-python">add<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> countdown<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">,</span> expires<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">)</span>
add<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expires<span class="token operator">=</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<ol start="4">
<li>link - выполнить другую задачу по завершению текущей, основываясь на результатах текущей</li>
</ol>
<pre class=" language-python"><code class="prism  language-python">add<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> link<span class="token operator">=</span>add<span class="token punctuation">.</span>s<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># ( 2 + 2 ) + 16</span>
</code></pre>
<h3 id="сelery-beat---переодические-задачи">Сelery beat - Переодические задачи</h3>
<p>Селери может выполнять какие-либо задачи просто по графику</p>
<p>Для этого нужно настроить приложение:</p>
<pre class=" language-python"><code class="prism  language-python">app<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>beat_schedule <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">'add-every-30-seconds'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token string">'task'</span><span class="token punctuation">:</span> <span class="token string">'tasks.add'</span><span class="token punctuation">,</span>
        <span class="token string">'schedule'</span><span class="token punctuation">:</span> <span class="token number">30.0</span><span class="token punctuation">,</span>
        <span class="token string">'args'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
app<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>timezone <span class="token operator">=</span> <span class="token string">'UTC'</span>

</code></pre>
<p><code>add-every-30-seconds</code> Ключ словаря, это только название, можно указать что угодно.</p>
<p><code>task</code> это выполняемый таск</p>
<p><code>args</code> его аргументы</p>
<p><code>schedule</code>: частота выполнения в секундах</p>
<h3 id="выполнение-по-крону">Выполнение по крону</h3>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> celery<span class="token punctuation">.</span>schedules <span class="token keyword">import</span> crontab

app<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>beat_schedule <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment"># Executes every Monday morning at 7:30 a.m.</span>
    <span class="token string">'add-every-monday-morning'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token string">'task'</span><span class="token punctuation">:</span> <span class="token string">'tasks.add'</span><span class="token punctuation">,</span>
        <span class="token string">'schedule'</span><span class="token punctuation">:</span> crontab<span class="token punctuation">(</span>hour<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> minute<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> day_of_week<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">'args'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Cron - система задания расписания, можно сделать практически какое угодно.</p>
<p>Для расписания нужно запускать отдельный воркер (beat) для расписания.</p>
<h3 id="celery-и-django">Celery и Django</h3>
<p>Для использования селери в django рекомендуется создать еще один файл <code>celery.py</code> на одном уровне с <code>settings.py</code></p>
<pre><code>- proj/
  - manage.py
  - proj/
    - celery.py
    - __init__.py
    - settings.py
    - urls.py
</code></pre>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">import</span> os

<span class="token keyword">from</span> celery <span class="token keyword">import</span> Celery

<span class="token comment"># set the default Django settings module for the 'celery' program.</span>
os<span class="token punctuation">.</span>environ<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">'DJANGO_SETTINGS_MODULE'</span><span class="token punctuation">,</span> <span class="token string">'proj.settings'</span><span class="token punctuation">)</span>

app <span class="token operator">=</span> Celery<span class="token punctuation">(</span><span class="token string">'proj'</span><span class="token punctuation">)</span>

<span class="token comment"># Using a string here means the worker doesn't have to serialize</span>
<span class="token comment"># the configuration object to child processes.</span>
<span class="token comment"># - namespace='CELERY' means all celery-related configuration keys</span>
<span class="token comment">#   should have a `CELERY_` prefix.</span>
app<span class="token punctuation">.</span>config_from_object<span class="token punctuation">(</span><span class="token string">'django.conf:settings'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'CELERY'</span><span class="token punctuation">)</span>

<span class="token comment"># Load task modules from all registered Django app configs.</span>
app<span class="token punctuation">.</span>autodiscover_tasks<span class="token punctuation">(</span><span class="token punctuation">)</span>

@app<span class="token punctuation">.</span>task<span class="token punctuation">(</span>bind<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">debug_task</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Request: {self.request!r}'</span><span class="token punctuation">)</span>
</code></pre>
<p>Параметр <code>namespace</code> при указании конфига будет отвечать за то с какого слова будут начинатся настройки в <code>settings.py</code></p>
<p>Например:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment"># Celery Configuration Options</span>
CELERY_BROKER_URL <span class="token operator">=</span> <span class="token string">'redis://localhost'</span>  
CELERY_RESULT_BACKEND <span class="token operator">=</span> <span class="token string">'redis://localhost'</span>
CELERY_TIMEZONE <span class="token operator">=</span> <span class="token string">'America/New_York'</span>
CELERY_TASK_TRACK_STARTED <span class="token operator">=</span> <span class="token boolean">True</span>
CELERY_TASK_TIME_LIMIT <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">60</span>
</code></pre>
<p><code>app.autodiscover_tasks()</code> - эта строчка будет отвечать за автоматический поиск таков во всех приложениях.</p>
<pre><code>- app1/
    - tasks.py
    - models.py
- app2/
    - tasks.py
    - models.py
</code></pre>
<p>На тоже же уровне где и <code>settings.py</code> создать\использовать файл <code>__init__.py</code> в зависимости от версии python</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment"># __init__.py</span>
<span class="token comment"># This will make sure the app is always imported when</span>
<span class="token comment"># Django starts so that shared_task will use this app.</span>
<span class="token keyword">from</span> <span class="token punctuation">.</span>celery <span class="token keyword">import</span> app <span class="token keyword">as</span> celery_app

__all__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'celery_app'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
</code></pre>
<p>Все задачи необходимо покрывать не стандартным декоратором <code>task</code>, а декоратором <code>shared_task</code> тогда django сможет автоматически найти все таски в приложении.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment"># tasks.py</span>

<span class="token keyword">from</span> celery <span class="token keyword">import</span> shared_task
<span class="token keyword">from</span> demoapp<span class="token punctuation">.</span>models <span class="token keyword">import</span> Widget


@shared_task
<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y


@shared_task
<span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> y


@shared_task
<span class="token keyword">def</span> <span class="token function">xsum</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>


@shared_task
<span class="token keyword">def</span> <span class="token function">count_widgets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> Widget<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span>


@shared_task
<span class="token keyword">def</span> <span class="token function">rename_widget</span><span class="token punctuation">(</span>widget_id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    w <span class="token operator">=</span> Widget<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token operator">=</span>widget_id<span class="token punctuation">)</span>
    w<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    w<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>Так же для Django существует много различных расширений, например:</p>
<p><code>django-celery-results</code> - что бы хранить резльутаты в бд или кеше джанго.</p>
<p><code>django-celery-beat</code> - настройка для переодических задач, сразу вшитая в админку джаго.</p>
<p>Классическим примером использования Celery является отправка электронной почты. Я использую этот пример, чтобы показать вам основы использования Celery. Для начало создадим view и задачу:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>conf <span class="token keyword">import</span> settings
<span class="token keyword">from</span> django<span class="token punctuation">.</span>core<span class="token punctuation">.</span>mail <span class="token keyword">import</span> send_mail
<span class="token keyword">from</span> django<span class="token punctuation">.</span>template <span class="token keyword">import</span> Engine<span class="token punctuation">,</span> Context

<span class="token keyword">from</span> myproject<span class="token punctuation">.</span>celery <span class="token keyword">import</span> app


<span class="token keyword">def</span> <span class="token function">render_template</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    engine <span class="token operator">=</span> Engine<span class="token punctuation">.</span>get_default<span class="token punctuation">(</span><span class="token punctuation">)</span>
    tmpl <span class="token operator">=</span> engine<span class="token punctuation">.</span>get_template<span class="token punctuation">(</span>template<span class="token punctuation">)</span>
    <span class="token keyword">return</span> tmpl<span class="token punctuation">.</span>render<span class="token punctuation">(</span>Context<span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    
@celery_app<span class="token punctuation">.</span>task
<span class="token keyword">def</span> <span class="token function">send_mail_task</span><span class="token punctuation">(</span>recipients<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> template<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    send_mail<span class="token punctuation">(</span>
        subject<span class="token operator">=</span>subject<span class="token punctuation">,</span>
        message<span class="token operator">=</span>render_template<span class="token punctuation">(</span>f<span class="token string">'{template}.txt'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">,</span>
        from_email<span class="token operator">=</span>settings<span class="token punctuation">.</span>DEFAULT_FROM_EMAIL<span class="token punctuation">,</span>
        recipient_list<span class="token operator">=</span>recipients<span class="token punctuation">,</span>
        fail_silently<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
        html_message<span class="token operator">=</span>render_template<span class="token punctuation">(</span>f<span class="token string">'{template}.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre>
<p>Используя Celery, мы сокращаем время ответа клиенту, поскольку отделяем процесс отправки от основного кода, отвечающего за возврат ответа.</p>
<p>Самый простой способ выполнить эту задачу — вызвать метод  <code>delay</code>, предоставляемый декоратором  app.task.</p>
<pre class=" language-python"><code class="prism  language-python">send_mail_task<span class="token punctuation">.</span>delay<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'noreply@example.com'</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Celery cookbook test'</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>Celery так же позволяет настроить повторные попытки после сбоя.</p>
<pre class=" language-python"><code class="prism  language-python">@celery_app<span class="token punctuation">.</span>task<span class="token punctuation">(</span>bind<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> default_retry_delay<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">send_mail_task</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> recipients<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> template<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    message <span class="token operator">=</span> render_template<span class="token punctuation">(</span>f<span class="token string">'{template}.txt'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
    html_message <span class="token operator">=</span> render_template<span class="token punctuation">(</span>f<span class="token string">'{template}.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        send_mail<span class="token punctuation">(</span>
            subject<span class="token operator">=</span>subject<span class="token punctuation">,</span>
            message<span class="token operator">=</span>message<span class="token punctuation">,</span>
            from_email<span class="token operator">=</span>settings<span class="token punctuation">.</span>DEFAULT_FROM_EMAIL<span class="token punctuation">,</span>
            recipient_list<span class="token operator">=</span>recipients<span class="token punctuation">,</span>
            fail_silently<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
            html_message<span class="token operator">=</span>html_message
        <span class="token punctuation">)</span>
    <span class="token keyword">except</span> smtplib<span class="token punctuation">.</span>SMTPException <span class="token keyword">as</span> ex<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>retry<span class="token punctuation">(</span>exc<span class="token operator">=</span>ex<span class="token punctuation">)</span>
</code></pre>
<p>Теперь задача будет перезапущена через десять минут, в случае если отправка не будет удачной. Кроме того, вы сможете установить количество повторных попыток.<br>
Hендеринг шаблона вынесен за пределы вызова <code>send_mail</code>. Это потому, что мы заключаем вызов  <code>send_mail</code>  в  <code>try / except</code>, и лучше иметь как можно меньше кода в  <code>try / except</code>.</p>
<h3 id="flower---инструмент-для-мониторинга-celery"><a href="https://flower.readthedocs.io/en/latest/">Flower</a> - инструмент для мониторинга Celery</h3>
<pre><code>pip install flower
</code></pre>
<p>запуск</p>
<pre><code>flower -A proj --port=5555
</code></pre>
<p>и из Celery</p>
<pre><code>celery flower -A proj --address=127.0.0.1 --port=5555
</code></pre>
<p><img src="https://flower.readthedocs.io/en/latest/_images/dashboard.png" alt="enter image description here"></p>
<h3 id="попрактиваться-в-качесвтве-д.з.">Попрактиваться в качесвтве Д.З.</h3>
<p>Повторить то, что сделано в <a href="https://www.youtube.com/watch?v=hQEHONHcF2c">видео</a></p>
<h2 id="литература">Литература</h2>
<ol>
<li><a href="https://webdevblog.ru/python-celery/">Введение в Celery Python</a></li>
<li><a href="https://khashtamov.com/ru/celery-best-practices/">Celery: начинаем правильно</a></li>
<li><a href="https://habr.com/ru/post/488654/">О RabbitMQ habr</a></li>
<li><a href="https://redis.io/topics/quickstart">Redis Quick Start</a></li>
<li><a href="https://docs.celeryproject.org/en/stable/getting-started/first-steps-with-celery.html">First Steps with Celery</a> and  <a href="https://docs.celeryproject.org/en/stable/getting-started/next-steps.html">Next Steps</a></li>
<li><a href="https://www.youtube.com/watch?v=s1vmVWCKefM&amp;list=PLF-NY6ldwAWqjBkanP1Tl50kDpIYXJBna">Видео</a>, но лучше сразу со второй части и перематывать</li>
</ol>

