---


---

<h1 id="celery">Celery</h1>
<p><img src="https://i.imgur.com/eUUBQaQ.jpg" alt="enter image description here"></p>
<h2 id="план">План</h2>
<h3 id="что-надо-знать-до-celery">Что надо знать до Celery</h3>
<p><strong>Процесс</strong> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.</p>
<p><strong>Поток</strong> использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.<br>
Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.</p>
<p><strong>Синхронным</strong> (synchronous) называется такое взаимодействие между компонентами, при котором клиент, отослав запрос, блокируется и может продолжать работу только после получения ответа от сервера. По этой причине такой вид взаимодействия называют иногда блокирующим (blocking).</p>
<p>В рамках <strong>асинхронного</strong> (asynchronous) или неблокирующего (non blocking) взаимодействия клиент после отправки запроса серверу может продолжать работу, даже если ответ на запрос еще не пришел. Асинхронное взаимодействие позволяет получить более высокую производительность системы за счет использования времени между отправкой запроса и получением ответа на него для выполнения других задач. Другое важное преимущество асинхронного взаимодействия — меньшая зависимость клиента от сервера, возможность продолжать работу, даже если машина, на которой находится сервер, стала недоступной. Это свойство используется для организации надежной связи между компонентами, даже если и клиент, и сервер не все время находятся в рабочем состоянии.<br>
<img src="https://media.proglib.io/wp-uploads/2018/07/introducing-the-volley-http-library-smashing-magazine.png" alt="асинхронный запрос к серверу"></p>
<p><strong>NoSQL</strong> (от англ. not only SQL — не только SQL) — термин, обозначающий ряд подходов, направленных на реализацию систем управления базами данных, имеющих существенные отличия от моделей, используемых в традиционных реляционных СУБД с доступом к данным средствами языка SQL. Применяется к базам данных, в которых делается попытка решить проблемы масштабируемости и доступности за счёт атомарности (англ. atomicity) и согласованности данных (англ. consistency). <a href="https://www.bigdataschool.ru/wiki/nosql#:~:text=NoSQL%20%E2%80%93%20%D1%8D%D1%82%D0%BE%20%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4%20%D0%BA%20%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8,%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%89%D0%B8%D0%B9%D1%81%D1%8F%20%D0%BE%D1%82%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%20%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D1%85%20%D0%A1%D0%A3%D0%91%D0%94.">Подробнее тут</a></p>
<p><img src="https://www.bigdataschool.ru/wp-content/uploads/2019/12/%D0%BD%D1%81%D0%BA%D0%BB_2.png" alt="NoSQL-базы данных"></p>
<h2 id="celery---распределённая-очередь-задач">Celery - распределённая очередь задач</h2>
<p><img src="https://docs.celeryproject.org/en/stable/_static/celery_512.png" alt="Logo"><br>
Celery это ничто иное как распределённая очередь задач, реализованная на языке Python.</p>
<p>Celery - это простая, гибкая и надежная распределенная система для обработки огромного количества сообщений, включаюзя в себя инструменты, необходимые для поддержки такой системы.</p>
<p>Это очередь задач с упором на обработку в реальном времени, а также с поддержкой планирования задач.</p>
<p>Celery имеет открытый исходный код и находится под лицензией BSD.</p>
<p>Итак, что же умеет <a href="https://docs.celeryproject.org/en/stable/">Celery</a>:</p>
<ul>
<li>Выполнять асинхронно задания</li>
<li>Выполнять периодические задания(умная замена cron)</li>
<li>Выполнять отложенные задания</li>
<li>Распределенное выполнение (может быть запущен на N серверах)</li>
<li>В пределах одного worker’а возможно конкурентное выполнение нескольких задач(одновременно)</li>
<li>Выполнять задание повторно, если вылез exception</li>
<li>Ограничивать количество заданий в единицу времени (rate limit, для задания или глобально)</li>
<li>Несложно мониторить выполнение заданий</li>
<li>Выполнять подзадания</li>
<li>Присылать отчеты об exception’ах</li>
<li>Проверять выполнилось ли задание</li>
</ul>
<h3 id="как-работает-celery">Как работает Celery</h3>
<p><img src="https://webmonstr.com/media/course/python-course/36-django-celery/images/2.png" alt="start page"></p>
<h4 id="brocker--брокер">Brocker  (Брокер)</h4>
<p>Брокер сообщений (он же диспетчер очереди) — это посредник(транспорт), который принимает и отдает сообщения (задачи) между отдельными модулями/приложениями внутри некоторой сложной системы, где модули/приложения должны общаться между собой — то есть пересылать данные друг другу.</p>
<h4 id="worker-воркер">Worker (Воркер)</h4>
<p>Воркер это отдельно запущенный процесс для выполнения определённых задач, Celery запускается на одном или нескольких воркерах, что бы выполнять задачи паралельно на каждом воркере.</p>
<h4 id="back-end-бэкэнд">Back-end (Бэкэнд)</h4>
<p>Бэкэнд в случае с Celery выступает в качестве хранилища результатов выполнения задач.</p>
<p><img src="https://www.ovh.com/blog/wp-content/uploads/2020/02/51EA37AB-E3E5-453F-9EFD-92414C84523F-1024x572.jpeg" alt=""></p>
<ul>
<li>
<p><strong>Producer</strong>  (поставщик) ‒ программа, отправляющая сообщения.</p>
</li>
<li>
<p><strong>Queue</strong>  (очередь) ‒ очередь сообщений(задач). Она существует внутри брокера. Любое количество поставщиков может отправлять сообщения в одну очередь, также любое количество подписчиков может получать сообщения из одной очереди. В схемах очередь будет обозначена стеком и подписана именем:</p>
</li>
<li>
<p><strong>Consumer</strong>  (подписчик) ‒ программа, принимающая сообщения. Обычно подписчик находится в состоянии ожидания сообщений.</p>
</li>
</ul>
<p>Поставщик, подписчик и брокер не обязаны находиться на одной физической машине.</p>
<h3 id="брокеры">Брокеры</h3>
<p><strong><a href="https://ru.wikipedia.org/wiki/AMQP">AMQP</a></strong><br>
(Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Основная идея состоит в том, что отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет маршрутизацию, возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений.</p>
<p><strong><a href="https://www.rabbitmq.com/download.html">RabbitMQ</a></strong></p>

